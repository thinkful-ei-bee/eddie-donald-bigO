// What is the Big O for this

// 1) O(1)
// 2) O(n)

// Even or Odd

// The BigO is constant (O(1)) because we are always
// going go through this single if statement and there
// is nothing else in the algorithm.

// Are you here?

// The BigO is polynomial (O(n^2)) because in our worst
// case scenario we would have to go through the first
// for loop and the nested for loop completely.

// Doubler

// The BigO is linear (O(n)) because we go through the
// entire array once in the for loop

// Naive search

// The BigO is linear (O(n)) because we go through the
// entire array once and the if statement evaluates
// once per array item

// Creating pairs

// The BigO is polynomial (O(n^2)) because the first loop
// would take us through every element of the argument array
// and then take every other element.

// Compute the sequence

// The following algorithm returns an array of fibonacci numbers
// based on the supplied integer num. A num of 5 will return
// five fibonacci numbers from the beginning (1,1,2,3,5).

// The runtime complexity is linear (O(n)) because the time the
// algorithm would take increases by a constant about for
// each increase in n (the integer supplied as num).

// An Efficient Search

// The Big O of the following algorithm is O(log(n)) because
// with each iteration of the while loop the array indices
// that are a part of the loop are halved.

// Random Element

// The Big O of the following algorithm is (O(1)) because
// the function is a simple return statement of one random
// element from a supplied array.

// What Am I?

// The following algorithm looks at whether a given number
// is a prime number. The BigO of the following algorithm is
// linear (O(n)) because for each increase in the given
// argument n there would be a proportionate increase in the
// number of for loops executed.

